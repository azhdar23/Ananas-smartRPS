// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";

contract RockPaperScissors {
    enum Move {ROCK, PAPER, SCISSORS}
    IERC20 public token;
    IERC721 public nft;
    uint256 public nftBonusID;
    uint256 public minBet;
    uint256 public maxRewardMultiplier;
    AggregatorV3Interface public oracle;
    uint256 public oracleFee;

    constructor(
        address _TOKEN,
        address _NFT,
        uint256 _NFTBONUSID,
        uint256 _MINBET,
        uint256 _MAXREWARDMULTIPLIER,
        address _ORACLE,
        uint256 _ORACLEFEE
    ) {
        token = IERC20(_TOKEN);  
        nft = IERC721(_NFT);  
        nftBonusID = _NFTBONUSID;  
        minBet = _MINBET;
        maxRewardMultiplier = _MAXREWARDMULTIPLIER;
        oracle = AggregatorV3Interface(_ORACLE);
        oracleFee = _ORACLEFEE;
    }

    function play(Move move, uint256 betAmount) external {
        require(betAmount >= minBet, "Bet amount is below the minimum");
        token.transferFrom(msg.sender, address(this), betAmount);

        (, int256 latestPrice, , , ) = oracle.latestRoundData();
        require(latestPrice > 0, "Oracle price data is invalid");

        uint256 randomNumber = uint256(latestPrice) % 3;
        Move opponentMove = Move(randomNumber);

        bool playerWon = didPlayerWin(move, opponentMove);

        if (playerWon) {
            uint256 rewardMultiplier = maxRewardMultiplier;
            if (nft.ownerOf(nftBonusID) == msg.sender) {
                rewardMultiplier += 1;
            }
            token.transfer(msg.sender, betAmount * rewardMultiplier);
        }
    }
